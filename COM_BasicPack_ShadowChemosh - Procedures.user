<?xml version="1.0" encoding="ISO-8859-1"?>
<document signature="Hero Lab Data">
  <loadonce key="COM_BasicPack_ShadowChemosh - Procedures"/>
  <fileinfo>
    <info_author><![CDATA[
      Author:  Tim Shadow
      Email: shadowchemosh@yahoo.com
      File Name changed from PFRPG_Adjustments_Procedure.user => COM_BasicPack_ShadowChemosh - Procedures.user
      ]]></info_author>
    <info_history><![CDATA[
    7/13/2014 Tim Shadow
    1) Fixed error that the leopard was throwing about darkvision.
    2) Fixed natural weapon damage that was not always being set.
    
    ]]>
    </info_history>
 </fileinfo>
 
<!-- =================================================================== -->
<!--                          Remove Armor                               -->
<!-- =================================================================== -->
  <procedure id="S2RmvArmor" context="pick"><![CDATA[
  ~Procedure is used to disable all armor on a character
    ~Loop through each armor on the character
    foreach pick in hero from BaseArmor where "!thingid.mNatural & EquipType.Armor"
        perform eachpick.assign[Helper.NoArmor]
        perform eachpick.delete[ArmorCateg.Slows]
        eachpick.field[arMaxDex].value = 999
        eachpick.field[arArcFail].value = 0
        eachpick.field[arArmorChk].value = 0
    nexteach
    ]]>
  </procedure>

<!-- =================================================================== -->
<!--                          Remove Shield                              -->
<!-- =================================================================== -->
  <procedure id="S2RmvShld" context="pick"><![CDATA[
  ~Procedure is used to disable just shields on a character
    ~Find the currently equipped shields on the character and remove it
    foreach pick in hero from BaseArmor where "EquipType.Shield"
        perform eachpick.assign[Helper.NoArmor]
        eachpick.field[arMaxDex].value = 999
        eachpick.field[arArcFail].value = 0
        eachpick.field[arArmorChk].value = 0
    nexteach
    ]]>
  </procedure>

<!-- =================================================================== -->
<!-- Remove Magic Items                                                  -->
<!-- Procedure is used to disable Wonderus items and Magic Rings.        -->
<!-- Needs to run at First/1000                                          -->
<!-- =================================================================== -->
  <procedure id="RmvMagItms" context="pick"><![CDATA[
    trustme
    ~ Find all Magic Rings and Magic Wonderous items and unequip them
    foreach pick in hero where "component.BaseWonder|component.BaseRing"
      eachpick.field[gIsEquip].value = 0  
    nexteach
    ]]>
  </procedure>

<!-- =================================================================== -->
<!-- Set abValues                                                        -->
<!-- Procedure is used to set the correct abValue field on a selected    -->
<!-- pick. Recommened to run in First/???????                            -->
<!-- =================================================================== -->
  <procedure id="S2AbValues" context="pick"><![CDATA[
    ~ If nothing chosen, get out now
    doneif (field[pChosen].ischosen <> 1)
    ~ If nothing chosen 2, get out now
    doneif (field[pChosen2].ischosen <> 1)

    ~ abValue 1 choosen
    If (field[pChosen2].chosen.tagis[Value.1] = 1) Then
      ~ Adjust the Value 1 field up or down
      field[pChosen].chosen.field[abValue].value += field[pAdjust].value
    ~ abValue 2 choosen
    ElseIf (field[pChosen2].chosen.tagis[Value.2] = 1) Then
      ~ Adjust the Value 2 field up or down
      field[pChosen].chosen.field[abValue2].value += field[pAdjust].value
    ~ abValue 3 choosen
    ElseIf (field[pChosen2].chosen.tagis[Value.3] = 1) Then
      ~ Adjust the Value 3 field up or down
      field[pChosen].chosen.field[abValue3].value += field[pAdjust].value
    ~ abValue 4 choosen
    ElseIf (field[pChosen2].chosen.tagis[Value.4] = 1) Then
      ~ Adjust the Value 2 field up or down
      field[pChosen].chosen.field[abValue4].value += field[pAdjust].value
    ~ abValue 4 choosen
    ElseIf (field[pChosen2].chosen.tagis[Value.4] = 1) Then
      ~ Adjust the Value 2 field up or down
      field[pChosen].chosen.field[abValue4].value += field[pAdjust].value
    ~ abValue 5 choosen
    ElseIf (field[pChosen2].chosen.tagis[Value.5] = 1) Then
      ~ Adjust the Value 2 field up or down
      field[pChosen].chosen.field[abValue5].value += field[pAdjust].value
    Endif
    ]]>
  </procedure>


<!-- =================================================================== -->
<!-- Set the natural attack damage for adjustments                       -->
<!-- =================================================================== -->
  <procedure id="S2SetNatDm" context="pick"><![CDATA[
    ~ If the default "Source" id is changed then attempt to use it.
    If (compare(field[pSource].text,"(source)") <> 0) Then
      ~ Make sure that we are not blank either.
      If (compare(field[pSource].text,"") <> 0) Then
        perform field[pChosen].chosen.delete[wMain.?]
        perform field[pChosen].chosen.assignstr["wMain." & field[pSource].text]
        done
      Endif
    Endif
     ~ Procedure is used to correctly set the natural attack damage based on the 
     ~ Bestiary Table: Natural Attacks by Size.
     If (field[pAdjust].value <> 0) Then
      ~ If starting from 1d6 die size    
      If (field[pChosen].chosen.tagis[wMain.1d6_5] <> 0) Then
        perform field[pChosen].chosen.delete[wMain.?]
        If (field[pAdjust].value = 1) Then
          perform field[pChosen].chosen.assign[wMain.1d8_6]
        ElseIf (field[pAdjust].value = 2) Then
          perform field[pChosen].chosen.assign[wMain.2d6_104]
        ElseIf (field[pAdjust].value = 3) Then
          perform field[pChosen].chosen.assign[wMain.2d8_204]
        ElseIf (field[pAdjust].value = 4) Then
          perform field[pChosen].chosen.assign[wMain.4d6_106]
        ElseIf (field[pAdjust].value = -1) Then
          perform field[pChosen].chosen.assign[wMain.1d4_4]
        ElseIf (field[pAdjust].value = -2) Then
          perform field[pChosen].chosen.assign[wMain.1d3_3]
        ElseIf (field[pAdjust].value = -3) Then
          perform field[pChosen].chosen.assign[wMain.1d2_2]
        ElseIf (field[pAdjust].value = -4) Then
          perform field[pChosen].chosen.assign[wMain.1_1]
        Endif
      ~..If starting from 1d4 die size
      Else
        perform field[pChosen].chosen.delete[wMain.?]
        If (field[pAdjust].value = 1) Then
          perform field[pChosen].chosen.assign[wMain.1d6_5]
        ElseIf (field[pAdjust].value = 2) Then
          perform field[pChosen].chosen.assign[wMain.1d8_6]
        ElseIf (field[pAdjust].value = 3) Then
          perform field[pChosen].chosen.assign[wMain.2d6_104]
        ElseIf (field[pAdjust].value = 4) Then
          perform field[pChosen].chosen.assign[wMain.2d8_204]
        ElseIf (field[pAdjust].value = -1) Then
          perform field[pChosen].chosen.assign[wMain.1d3_3]
        ElseIf (field[pAdjust].value = -2) Then
          perform field[pChosen].chosen.assign[wMain.1d2_2]
        ElseIf (field[pAdjust].value = -3) Then
          perform field[pChosen].chosen.assign[wMain.1_1]
        ElseIf (field[pAdjust].value = -4) Then
          perform field[pChosen].chosen.assign[wMain.1_1]
        Endif
      Endif
     Endif
     ]]>
  </procedure>

<!-- =================================================================== -->
  <!-- 
  Set the Custom Name and Custom Text adjustments logic into this single
  procedure. We need to allow for using the Duration field or the Source
  field for setting the name so that we are backwards compatable.
  Timing: Render/99999999
  -->
<!-- =================================================================== -->
  <procedure id="S2SetName" context="pick"><![CDATA[
    ~ 1 = Source
    ~ 2 = Duration
    var S2Type as number

    ~ If the default "(duration)" text is changed then attempt to use it.
    If (compare(field[pDuration].text,"(duration)") <> 0) Then
      ~ Make sure that we are not blank either.
      If (compare(field[pDuration].text,"") <> 0) Then
        S2Type = 2
      Endif
    Endif

    ~ If the default "(source)" text is changed then attempt to use it.
    If (compare(field[pSource].text,"(source)") <> 0) Then
      ~ Make sure that we are not blank either.
      If (compare(field[pSource].text,"") <> 0) Then
        S2Type = 1
      Endif
    Endif

    ~ The tag AdjShadow.Name means we are totally overwriting the live name value
    If (tagis[AdjShadow.Name] <> 0) Then

      ~ Source field has text to use so use it
      If (S2Type = 1) Then
        field[pChosen].chosen.field[livename].text = field[pSource].text

      ~ Duration field has text and Source does not so use it
      ElseIf (S2Type = 2) Then
        field[pChosen].chosen.field[livename].text = field[pDuration].text      
      Endif

    ~ The tag AdjShadow.Text means we are appending to the live name value
    ElseIf (tagis[AdjShadow.Text] <> 0) Then

      ~ Source field has text to use so use it
      If (S2Type = 1) Then
        field[pChosen].chosen.field[livename].text &= field[pSource].text

      ~ Duration field has text and Source does not so use it
      ElseIf (S2Type = 2) Then
        field[pChosen].chosen.field[livename].text &= field[pDuration].text      
      Endif
    Endif]]>
  </procedure>

<!-- =================================================================== -->
   <!-- 
   Calculate the concentration value of a specific class. Do this using
   soft-coded parms so that we can easily support the APG and UM classes.
   Plus this should allow others to easily add new concentration skills
   for 3PP classes or house ruled classes.
   Timing: Final/50000
   -->
<!-- =================================================================== -->
  <procedure id="S2CalcConc" context="pick"><![CDATA[
    ~ Parm passed in with the class Unique ID.
    var S2_Class as string

    ~ We are not a real skill so we don't want to have an ability
    ~ linked to us.
    perform delete[SkillAbil.?]

    ~ If class "thingid" is blank then get out now!
    doneif (empty(S2_Class) = 1)

    ~ If we are a racial Concentration skill then get the race field
    if (compare(S2_Class,"Race") = 0) then
      field[skTotal].value = hero.findchild[BaseRace].field[rSpConcen].value      
    
    ~..Get the passed in "Cass" concentration value
    else
      ~ append the thingid.? group to the tag id.
      S2_Class = "thingid." & S2_Class
      ~ Calculate the total concentration value
      field[skTotal].value = hero.findchild[BaseClHelp,S2_Class].field[cConcCheck].value
    endif

    ~ Add in all the different "bonus" and "penalty" fields
    field[skTotal].value += field[Bonus].value + field[Penalty].value + field[BonAlch].value + field[ModCirc].value + field[BonComp].value + field[PenComp].value + field[BonEnhance].value + field[BonInsight].value + field[BonLuck].value + field[PenLuck].value + field[BonMorale].value + field[PenMorale].value + field[BonProfane].value + field[PenProfane].value + field[BonSacred].value + field[PenSacred].value + field[BonTrait].value + field[PenTrait].value    

    ~ --------------------------------------------
    ~ Situational Feats
    ~ --------------------------------------------

    ~ If we have the combat casting feat add a situational note
    If (hero.tagis[HasFeat.fComCast] <> 0) Then
      #situational[this,"+4 bonus when casting defensivley or grappled.","Combat Casting"]    
    Endif

    ~ If we have the Dimensional Agility feat add a situational note
    If (hero.tagcountstr["HasFeat.fDimenAgil"] <> 0) Then
      #situational[this,"+4 bonus when casting teleportation spells.","Dimensional Agility"]    
    Endif

    ~ If we have the Shielded Caster feat add a situational note
    If (hero.tagcountstr["HasFeat.fShieldCas"] <> 0) Then
      #situational[this,"+4 compentence bonus when adjacent to an ally.","Shielded Caster"]    
    Endif

    ~ If we have the Unusual Origin (Changeling) feat add a situational note
    If (hero.tagcountstr["HasFeat.fUnOrigCha"] <> 0) Then
      #situational[this,"+2 bonus when within 30ft of two other changelings.","Unusual Origin (Changeling)"]    
    Endif

    ~ If we have the Warrior Priest feat add a situational note
    If (hero.tagcountstr["HasFeat.fWarriPrie"] <> 0) Then
      #situational[this,"+2 bonus when casting defensivley or grappled.","Warrior Priest"]    
    Endif
    
    ~ If we have the Grappled Caster feat add a situational note
    If (hero.tagcountstr["HasFeat.fGrapCaste"] <> 0) Then
      #situational[this,"+4 bonus when grappled which stacks with Combat Casting bonus.","Grappled Caster"]    
    Endif


    ~ If we have the Focused Eidolon feat add a situational note
    If (hero.tagcountstr["HasFeat.fFocusEido"] <> 0) Then
      #situational[this,"+4 bonus when adjacent to your eidolon.","Focused Eidolon"]    
    Endif

    ~ If we have the Mage of the Wild feat add a situational note
    If (hero.tagcountstr["HasFeat.fMageWild"] <> 0) Then
      #situational[this,"+2 bonus when you are in a terrain type you have selected the Attuned to the Wild feat for.","Mage of the Wild"]    
    Endif

    ~ If we have the Meditative Concentration feat add a situational note
    If (hero.tagcountstr["HasFeat.fMedConcen"] <> 0) Then
      #situational[this,"+4 bonus after you perform combat meditation.","Meditative Concentration"]    
    Endif

    ~ If we have the Perfect Center feat add a situational note
    If (hero.tagcountstr["HasFeat.fPerCenter"] <> 0) Then
      #situational[this,"You can take 10 even if it is not normally allowed due to strenuous circumstances.","Perfect Center"]    
    Endif
    
    ~ If we have the Uncanny Concentration feat add a situational note
    If (hero.tagcountstr["HasFeat.fUncanConc"] <> 0) Then
      #situational[this,"You do not need to make concentration checks when affected by vigorous or violent motion or by violent weather.","Uncanny Concentration"]    
    Endif

    ~ If we have the Waterway Caster feat add a situational note
    If (hero.tagcountstr["HasFeat.fWaterCast"] <> 0) Then
      #situational[this,"+4 bonus when casting spells underwater. Automatically succeed while subjected to vigorouis or violent motion while swimming or on a ship.","Waterway Caster"]    
    Endif

    ~ --------------------------------------------
    ~ Situational Traits
    ~ --------------------------------------------

    ~ If we have the Battlefield Caster trait add a situational note
    If (hero.tagcountstr["HasTrait.trBattle"] <> 0) Then
      #situational[this,"+1 trait bonus when casting defensively.","Battlefield Caster"]    
    Endif

    ~ If we have the Kuthite Caster trait add a situational note
    If (hero.tagcountstr["HasTrait.trKuthCast"] <> 0) Then
      #situational[this,"+4 trait bonus when casting spells with the darkness, pain, or shadow descriptors.","Kuthite Caster"]    
    Endif

    ~ If we have the Kwanlai Believer trait add a situational note
    If (hero.tagcountstr["HasTrait.trKwanlaiB"] <> 0) Then
      #situational[this,"+2 trait bonus when casting divine spells.","Kwanlai Believer"]    
    Endif

    ~ If we have the Quantium University Graduate trait add a situational note
    If (hero.tagcountstr["HasTrait.trQuUnGrad"] <> 0) Then
      #situational[this,"+2 trait bonus when casting arcane spells.","Quantium University Graduate"]    
    Endif

    ~ If we have the Scion of the Shory trait add a situational note
    If (hero.tagcountstr["HasTrait.trScionSho"] <> 0) Then
      #situational[this,"+2 bonus when casting flight spells such as {i}levitate, fly{/i} or {i}overland flight{/i}.","Scion of the Shory"]    
    Endif    

    ~ If we have the Shipboard Caster trait add a situational note
    If (hero.tagcountstr["HasTrait.trShipCast"] <> 0) Then
      #situational[this,"+3 bonus when on a ship or other water-going vessel.","Shipboard Caster"]    
    Endif
    ]]>
  </procedure>

<!-- =================================================================== -->
   <!-- 
   Calculate the Caster Level vs Spell Resistance.
   Timing: Final/50000
   -->
<!-- =================================================================== -->
  <procedure id="S2CalcClSr" context="pick"><![CDATA[
    ~ We are not a real skill so we don't want to have an ability
    ~ linked to us.
    perform delete[SkillAbil.?] 

    ~ --------------------------------------------
    ~ Situational Racial Specials
    ~ --------------------------------------------

    ~ --------------------------------------------
    ~ Situational Feats
    ~ --------------------------------------------
    ~ If we have the Allied Spellcaster feat add a situational note
    If (hero.tagcountstr["HasFeat.fAllSpellc"] <> 0) Then
      #situational[this,"+4 bonus whenever you are adjacent to an ally who also has this feat.","Allied Spellcaster"]    
    Endif
    ~ If we have the Ancient Draconic feat add a situational note
    If (hero.tagcountstr["HasFeat.fAncientDr"] <> 0) Then
      #situational[this,"+1 bonus when casting arcane spells that have a verbal component.","Ancient Draconic"]    
    Endif
    ~ If we have the Demon Hunter feat add a situational note
    If (hero.tagcountstr["HasFeat.fDemonHunt"] <> 0) Then
      #situational[this,"+2 morale bonus against creatures with the demon subtype you recognize as demons.","Demon Hunter"]    
    Endif
    ~ If we have the Diviner's Delving feat add a situational note
    If (hero.tagcountstr["HasFeat.fDivDelve"] <> 0) Then
      #situational[this,"+2 bonus with divinations to overcome SR or effects that impede divination (for example {i}nondetection{/i}).","Diviner's Delving"]    
    Endif
    ~ If we have the Giant-Bane Caster feat add a situational note
    If (hero.tagcountstr["HasFeat.fGiantBane"] <> 0) Then
      #situational[this,"+1/2 favored enemy bonus against giants.","Giant-Bane Caster"]    
    Endif

    ~ --------------------------------------------
    ~ Situational Traits
    ~ --------------------------------------------
    ~ If we have the Dedicated Defender trait add a situational note
    If (hero.tagcountstr["HasTrait.trDediDefe"] <> 0) Then
      #situational[this,"+1 trait bonus while you are adjacent to a dying or disabled ally.","Dedicated Defender"]    
    Endif
    ~ If we have the Earthbound trait add a situational note
    If (hero.tagcountstr["HasTrait.trDediDefe"] <> 0) Then
      #situational[this,"+2 trait bonus vs creatures with the air subtype.","Earthbound"]    
    Endif
    ~ If we have the Insistent Benefactor trait add a situational note
    If (hero.tagcountstr["HasTrait.trInsisBen"] <> 0) Then
      #situational[this,"+2 trait bonus when you cast a harmless spell..","Insistent Benefactor"]    
    Endif
    ~ If we have the Magic's Might trait give a +1 trait bonus
    If (hero.tagcountstr["HasTrait.trMagMight"] <> 0) Then
      #applybonus[BonTrait,this,1]    
    Endif
    ~ If we have the Riftwarden Orphan trait add a situational note
    If (hero.tagcountstr["HasTrait.trRiftMage"] <> 0) Then
      #situational[this,"+4 trait bonus to penetrate a demon's spell resistance.","Riftwarden Orphan"]    
    Endif
    ~ If we have the Triaxian Dragonslayer trait add a situational note
    If (hero.tagcountstr["HasTrait.trTriaxDra"] <> 0) Then
      #situational[this,"+1 trait bonus vs dragon's spell resistance.","Triaxian Dragonslayer"]    
    Endif

    ~ -----------------------------------------------------
    ~ Add in all the different "bonus" and "penalty" fields
    ~ -----------------------------------------------------
    field[skTotal].value += field[Bonus].value + field[Penalty].value + field[BonAlch].value + field[ModCirc].value + field[BonComp].value + field[PenComp].value + field[BonEnhance].value + field[BonInsight].value + field[BonLuck].value + field[PenLuck].value + field[BonMorale].value + field[PenMorale].value + field[BonProfane].value + field[PenProfane].value + field[BonSacred].value + field[PenSacred].value + field[BonTrait].value + field[PenTrait].value    
    ]]>
  </procedure>


<!-- =================================================================================== -->
<!--                          Polymorph Procedures                                       -->
<!-- =================================================================================== -->
  <!--
    Procedure is used to meld all armor/shields on a character. So that the armor
    no longer affects any part of the character.
    Timing: Pre-Levels/10000
  -->
  <procedure id="S2MeldGear" context="pick"><![CDATA[
    ~ If we're not enabled, get out now
    doneif (field[pIsOn].value <> 1)

    ~ Loop through each armor on the character
    foreach pick in hero from BaseArmor where "!thingid.mNatural &  !Ability.iWild & (EquipType.Armor|EquipType.Shield)"
        perform eachpick.assign[Helper.NoArmor]
        perform eachpick.delete[ArmorCateg.Slows]
        eachpick.field[arMaxDex].value = 999
        eachpick.field[arArcFail].value = 0
        eachpick.field[arArmorChk].value = 0
        eachpick.field[gWeight].value = 0
    nexteach
    ]]>
  </procedure>

<!-- =================================================================== -->
  <!--
    Procedure is used to disable Wonderus items and Magic Rings.
    Needs to run at First/1000
  -->
<!-- =================================================================== -->
  <procedure id="S2RmvMagIt" context="pick"><![CDATA[
    trustme
    ~ Find all Magic Rings and Magic Wonderous items and unequip them
    foreach pick in hero where "component.BaseWonder|component.BaseRing"
      eachpick.field[gIsEquip].value = 0  
    nexteach
    ]]>
  </procedure>

<!-- =================================================================== -->
  <!--
    This procedure setups up the tags that get pulled from the chosen creature
    and moves them correctly to the hero or other places.
  -->
<!-- =================================================================== -->
  <procedure id="SCPolySet" context="pick"><![CDATA[
    ~ Set the livename 
    ~ If nothing's been chosen, get out now
    If (field[pChosen].ischosen <> 0) Then
      field[livename].text = field[name].text & ": " & field[pChosen].chosen.field[name].text
    Endif

    ~ If we're not enabled, get out now
    doneif (field[pIsOn].value <> 1)
    ~ If nothing's been chosen, get out now
    doneif (field[pChosen].ischosen <> 1)

    ~ Set the active tag on the hero so other mechanics run correctly.
    perform hero.assign[PolyAdjust.Active]
    
    perform field[pChosen].chosen.pulltags[PolyAdjust.?]
    perform field[pChosen].chosen.pulltags[PolySpell.?]
    perform field[pChosen].chosen.pulltags[PolyCreTy.?]
    perform field[pChosen].chosen.pulltags[PolyLegs.?]
    perform field[pChosen].chosen.pulltags[PolyImmune.?]
    perform field[pChosen].chosen.pulltags[PolyResist.?]
    perform field[pChosen].chosen.pulltags[PolyVulner.?]
    perform field[pChosen].chosen.pulltags[RaceSize.?]
    perform field[pChosen].chosen.pulltags[wBite.?]
    perform field[pChosen].chosen.pulltags[wClaw.?]
    perform field[pChosen].chosen.pulltags[wConstrict.?]
    perform field[pChosen].chosen.pulltags[wGore.?]
    perform field[pChosen].chosen.pulltags[wHooves.?]
    perform field[pChosen].chosen.pulltags[wRake.?]
    perform field[pChosen].chosen.pulltags[wRend.?]
    perform field[pChosen].chosen.pulltags[wSlam.?]
    perform field[pChosen].chosen.pulltags[wTailSlap.?]
    perform field[pChosen].chosen.pulltags[wTalon.?]
    perform field[pChosen].chosen.pulltags[wTentacle.?]
    perform field[pChosen].chosen.pulltags[wTrample.?]
    perform field[pChosen].chosen.pulltags[wWing.?]
    perform field[pChosen].chosen.pulltags[wManSpike.?]
    perform field[pChosen].chosen.pulltags[nBite.?]
    perform field[pChosen].chosen.pulltags[nClaw.?]
    perform field[pChosen].chosen.pulltags[nConstrict.?]
    perform field[pChosen].chosen.pulltags[nGore.?]
    perform field[pChosen].chosen.pulltags[nHooves.?]
    perform field[pChosen].chosen.pulltags[nRake.?]
    perform field[pChosen].chosen.pulltags[nRend.?]
    perform field[pChosen].chosen.pulltags[nSlam.?]
    perform field[pChosen].chosen.pulltags[nTailSlap.?]
    perform field[pChosen].chosen.pulltags[nTalon.?]
    perform field[pChosen].chosen.pulltags[nTentacle.?]
    perform field[pChosen].chosen.pulltags[nTrample.?]
    perform field[pChosen].chosen.pulltags[nWing.?]
    perform field[pChosen].chosen.pulltags[nManSpike.?]
    perform hero.pushtags[PolyAdjust.?]
    perform hero.pushtags[wBite.?]
    perform hero.pushtags[wClaw.?]
    perform hero.pushtags[wConstrict.?]
    perform hero.pushtags[wGore.?]
    perform hero.pushtags[wHooves.?]
    perform hero.pushtags[wRake.?]
    perform hero.pushtags[wRend.?]
    perform hero.pushtags[wSlam.?]
    perform hero.pushtags[wTailSlap.?]
    perform hero.pushtags[wTalon.?]
    perform hero.pushtags[wTentacle.?]
    perform hero.pushtags[wTrample.?]
    perform hero.pushtags[wWing.?]
    ]]>
  </procedure>

<!-- =================================================================== -->
  <!--
    This procedure sets the tags and values onto the custom Web Racial Special.
  -->
<!-- =================================================================== -->
  <procedure id="SCPolyWeb" context="pick"><![CDATA[
    ~ If no web tag then just get out now
    doneif (tagis[PolyAdjust.Web] <> 1)
      
    ~set our focus to the Web Racial Special
    perform hero.child[raS2Web].setfocus
    doneif (state.isfocus = 0)

    ~ set web attack bonus
    focus.field[wRanAtk].value = field[pChosen].chosen.field[phWebAtk].value
    ~ set web DC value
    focus.field[abDC].value = field[pChosen].chosen.field[phWebDC].value
    ]]>
  </procedure>

<!-- =================================================================== -->
  <!--
    This procedure sets the tags and values onto the custom Jet Racial Special.
  -->
<!-- =================================================================== -->
  <procedure id="SCPolyJet" context="pick"><![CDATA[
    ~ If no Jet tag then just get out now
    doneif (tagis[PolyAdjust.Jet] <> 1)

    ~ Set our jet speed in feets
    #value[raS2Jet] += field[pChosen].chosen.field[phJet].value
    ]]>
  </procedure>

<!-- =================================================================== -->
  <!--
    This procedure setups up the tags and values onto the polymorph racial special
    for poison.
  -->
<!-- =================================================================== -->
  <procedure id="SCPolyPois" context="pick"><![CDATA[
    ~ If no poison tag then just get out now
    doneif (tagis[PolyAdjust.Poison] <> 1)
    ~ If the poison Polymorph Racial Special not live get out now!
    doneif (hero.childlives[raS2Poison] <> 1)
    
    ~ Pull all poison tags
    perform field[pChosen].chosen.pulltags[PoisDamMod.?]
    perform field[pChosen].chosen.pulltags[PoisDamTyp.?]
    perform field[pChosen].chosen.pulltags[PoisonAttr.?]
    perform field[pChosen].chosen.pulltags[PoisonCat.?]
    perform field[pChosen].chosen.pulltags[PoisOnset.?]
    perform field[pChosen].chosen.pulltags[PoisLasts.?]
    perform field[pChosen].chosen.pulltags[Target.?]    
    
    ~set our focus to the Polymorph Adjustment Posion Racial Special
    perform hero.child[raS2Poison].setfocus
    doneif (state.isfocus = 0)

    ~ Die ype of damage
    focus.field[abValue].value = field[pChosen].chosen.field[phPoDieSze].value
    ~ Number of Saves
    focus.field[abValue2].value = field[pChosen].chosen.field[phPoSaves].value
    ~ Number of dice of damage
    focus.field[abValue3].value = field[pChosen].chosen.field[phPoDice].value
    ~ Duration of poison
    focus.field[abDuration].value = field[pChosen].chosen.field[phPoDurati].value
    ~ Push all the poison tags
    perform focus.pushtags[PoisDamMod.?]
    perform focus.pushtags[PoisDamTyp.?]
    perform focus.pushtags[PoisonAttr.?]
    perform focus.pushtags[PoisonCat.?]
    perform focus.pushtags[PoisOnset.?]
    perform focus.pushtags[PoisLasts.?]
    perform focus.pushtags[Target.?]    

    ]]>
  </procedure>

<!-- =================================================================== -->
  <!--
    This procedure setups up the tags and values for polymorph speeds: Swim, Climb, Fly, and Burrow.
  -->
<!-- =================================================================== -->
  <procedure id="SCPolyMove" context="pick"><![CDATA[

    ~ Set the new base speed here
    hero.child[Speed].field[tSpeed].value = field[pChosen].chosen.field[phSpeed].value
    
    ~ If we have no special movement speeds then get out now!
    doneif (field[pChosen].chosen.field[phBurrow].value + field[pChosen].chosen.field[phClimb].value + field[pChosen].chosen.field[phFly].value + field[pChosen].chosen.field[phSwim].value = 0) 
    
    ~ Set the correct maximum movement based on the type of Polymorph Spell.
    ~ Beast Shape 1
    If (tagis[PolyAdjust.Beast1] <> 0) Then
      #value[xSwim]  += minimum(field[pChosen].chosen.field[phSwim].value,field[pChosen].chosen.field[b1Swim].value)
      #value[xClimb] += minimum(field[pChosen].chosen.field[phClimb].value,field[pChosen].chosen.field[b1Climb].value)
      #value[xFly]   += minimum(field[pChosen].chosen.field[phFly].value,field[pChosen].chosen.field[b1Fly].value)
      ~ If we have Darkvision then try and set its value
      If (hero.tagis[PolyAdjust.Darkvision] <> 0) Then
        #value[raDarkVis] = minimum(field[pChosen].chosen.field[phDarkvis].value,field[pChosen].chosen.field[b1Darkvis].value)
      Endif

    ~ Beast Shape 2
    ElseIf (tagis[PolyAdjust.Beast2] <> 0) Then
      #value[xSwim]  += minimum(field[pChosen].chosen.field[phSwim].value,field[pChosen].chosen.field[b2Swim].value)
      #value[xClimb] += minimum(field[pChosen].chosen.field[phClimb].value,field[pChosen].chosen.field[b2Climb].value)
      #value[xFly]   += minimum(field[pChosen].chosen.field[phFly].value,field[pChosen].chosen.field[b2Fly].value)
      ~ If we have Darkvision then try and set its value
      If (hero.tagis[PolyAdjust.Darkvision] <> 0) Then
        #value[raDarkVis] = minimum(field[pChosen].chosen.field[phDarkvis].value,field[pChosen].chosen.field[b2Darkvis].value)
      Endif

    ~ Beast Shape 3
    ElseIf (tagis[PolyAdjust.Beast3] <> 0) Then
      #value[xSwim]   += minimum(field[pChosen].chosen.field[phSwim].value,field[pChosen].chosen.field[b3Swim].value)
      #value[xClimb]  += minimum(field[pChosen].chosen.field[phClimb].value,field[pChosen].chosen.field[b3Climb].value)
      #value[xFly]    += minimum(field[pChosen].chosen.field[phFly].value,field[pChosen].chosen.field[b3Fly].value)
      #value[xBurrow] += minimum(field[pChosen].chosen.field[phFly].value,field[pChosen].chosen.field[b3Burrow].value)
      ~ If we have Darkvision then try and set its value
      If (hero.tagis[PolyAdjust.Darkvision] <> 0) Then
        #value[raDarkVis] = minimum(field[pChosen].chosen.field[phDarkvis].value,field[pChosen].chosen.field[b3Darkvis].value)
      Endif

    ~ Beast Shape 4
    ElseIf (tagis[PolyAdjust.Beast4] <> 0) Then
      #value[xSwim]   += minimum(field[pChosen].chosen.field[phSwim].value,field[pChosen].chosen.field[b4Swim].value)
      #value[xClimb]  += minimum(field[pChosen].chosen.field[phClimb].value,field[pChosen].chosen.field[b4Climb].value)
      #value[xFly]    += minimum(field[pChosen].chosen.field[phFly].value,field[pChosen].chosen.field[b4Fly].value)
      #value[xBurrow] += minimum(field[pChosen].chosen.field[phBurrow].value,field[pChosen].chosen.field[b4Burrow].value)
      ~ If we have Darkvision then try and set its value
      If (hero.tagis[PolyAdjust.Darkvision] <> 0) Then
        #value[raDarkVis] = minimum(field[pChosen].chosen.field[phDarkvis].value,field[pChosen].chosen.field[b4Darkvis].value)
      Endif
    Endif
    ]]>
  </procedure>

<!-- =================================================================== -->
  <!--
    This is the main procedure for polymorphing a hero into a creature.
  -->
<!-- =================================================================== -->
  <procedure id="SCBeastSha" context="pick"><![CDATA[
    ~ If we're not enabled, get out now
    doneif (field[pIsOn].value <> 1)
    ~if nothing's been chosen, get out now
    doneif (field[pChosen].ischosen <> 1)

    ~ Setup the Base, Fly, Climb, and Burrow movement speeds
    Call SCPolyMove


    ~sizetarget is our incoming variable - the tSize that the character will be set to
    var sizetarget as number 
    ~sizemod is our outgoing variable - the modifier to the existing tSize
    ~that's needed in order to get to that target size
    var sizemod as number

    ~ If we have four legs we get a bonus vs Trip attacks
    If (tagis[PolyLegs.4Legs] <> 0) Then   
      ~ Bonus to Trip CMD cause of four legs
      hero.child[manTrip].field[manCMD].value += 4
      perform hero.findchild[BaseRace].assign[Helper.Quadruped]
    ~ If we have six legs we get a bonus vs Trip attacks
    ElseIf (tagis[PolyLegs.6Legs] <> 0) Then   
      ~ Bonus to Trip CMD cause of four legs
      hero.child[manTrip].field[manCMD].value += 6
      perform hero.findchild[BaseRace].assign[Helper.Quadruped]
    ~..If we have no legs we are immune to trips
    ElseIf (tagis[PolyLegs.0Legs] <> 0) Then   
      perform hero.assign[Helper.Snaky]
    ~..If we have fins then set our base speed to zero
    ElseIf (tagis[PolyLegs.Fins] <> 0) Then   
      hero.child[Speed].field[tSpeed].value = 0
    Endif

    ~ If an animal process here
    ~ =================================================
    If (tagis[PolyCreTy.Animal] <> 0) Then
      ~ Diminutive
      If (tagis[RaceSize.Dimin13] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Penalty].value += -2
        ~ Adjust Dexterity
        hero.child[aDEX].field[Bonus].value += 4
        ~ Adjust natural armor class
        hero.child[mNatural].field[Bonus].value += 1         
      ~ Tiny
      ElseIf (tagis[RaceSize.Tiny12] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Penalty].value += -2
        ~ Adjust Dexterity
        hero.child[aDEX].field[Bonus].value += 4
        ~ Adjust natural armor class
        hero.child[mNatural].field[Bonus].value += 1         
      ~ Small
      ElseIf (tagis[RaceSize.Small11] <> 0) Then
        ~ Adjust Dexterity
        hero.child[aDEX].field[Bonus].value += 2
        ~ Adjust natural armor class
        hero.child[mNatural].field[Bonus].value += 1         
      ~ Medium
      ElseIf (tagis[RaceSize.Medium0] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Bonus].value += 2
        ~ Adjust natural armor class
        hero.child[mNatural].field[Bonus].value += 2
      ~ Large
      ElseIf (tagis[RaceSize.Large1] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Bonus].value += 4
        ~ Adjust Dexterity
        hero.child[aDEX].field[Penalty].value += -2
        ~ Add to our armor class
        hero.child[mNatural].field[Bonus].value += 4
      ~ Huge
      ElseIf (tagis[RaceSize.Huge2] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Bonus].value += 6
        ~ Adjust Dexterity
        hero.child[aDEX].field[Penalty].value += -4
        ~ Add to our armor class
        hero.child[mNatural].field[Bonus].value += 6
      Endif
    ~ ..If an Magical Beast process here
    ~ =================================================
    ElseIf (tagis[PolyCreTy.MagicBeast] <> 0) Then
      ~ Tiny
      If (tagis[RaceSize.Tiny12] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Penalty].value += -2
        ~ Adjust Dexterity
        hero.child[aDEX].field[Bonus].value += 8
        ~ Adjust natural armor class
        hero.child[mNatural].field[Bonus].value += 3
      ~ Small
      ElseIf (tagis[RaceSize.Small11] <> 0) Then
        ~ Adjust Dexterity
        hero.child[aDEX].field[Bonus].value += 4
        ~ Adjust natural armor class
        hero.child[mNatural].field[Bonus].value += 2         
      ~ Medium
      ElseIf (tagis[RaceSize.Medium0] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Bonus].value += 4
        ~ Adjust natural armor class
        hero.child[mNatural].field[Bonus].value += 4
      ~ Large
      ElseIf (tagis[RaceSize.Large1] <> 0) Then
        ~ Adjust Strength
        hero.child[aSTR].field[Bonus].value += 6
        ~ Adjust Constitution
        hero.child[aCON].field[Bonus].value += 2
        ~ Adjust Dexterity
        hero.child[aDEX].field[Penalty].value += -2
        ~ Add to our armor class
        hero.child[mNatural].field[Bonus].value += 6
      Endif
    Endif

    var sValue as string
    var nValue as number
    
    ~ Set the correct value for our Poly Adjustment Natural Attacks
    foreach pick in hero from BaseNatWep where "PolyAdjust.Weapon"
      ~ We need to push Polymorph Damage Tags to the right natural attack
      If (eachpick.tagis[thingid.wBite] + tagcount[wBite.?] = 2) Then
        perform eachpick.pushtags[wBite.?,wMain]
        perform eachpick.pushtags[nBite.?,Value]
      Endif
      If (eachpick.tagis[thingid.wClaw] + tagcount[wClaw.?] = 2) Then
        perform eachpick.pushtags[wClaw.?,wMain]
        perform eachpick.pushtags[nClaw.?,Value]
      Endif
      If (eachpick.tagis[thingid.wConstrict] + tagcount[wConstrict.?] = 2) Then
        perform eachpick.pushtags[wConstrict.?,wMain]
        perform eachpick.pushtags[nConstrict.?,Value]
      Endif
      If (eachpick.tagis[thingid.wGore] + tagcount[wGore.?] = 2) Then
        perform eachpick.pushtags[wGore.?,wMain]
        perform eachpick.pushtags[nGore.?,Value]
      Endif
      If (eachpick.tagis[thingid.wHooves] + tagcount[wHooves.?] = 2) Then
        perform eachpick.pushtags[wHooves.?,wMain]
        perform eachpick.pushtags[nHooves.?,Value]
      Endif
      If (eachpick.tagis[thingid.wRake] + tagcount[wRake.?] = 2) Then
        perform eachpick.pushtags[wRake.?,wMain]
        perform eachpick.pushtags[nRake.?,Value]
      Endif
      If (eachpick.tagis[thingid.wRend] + tagcount[wRend.?] = 2) Then
        perform eachpick.pushtags[wRend.?,wMain]
        perform eachpick.pushtags[nRend.?,Value]
      Endif
      If (eachpick.tagis[thingid.wSlam] + tagcount[wSlam.?] = 2) Then
        perform eachpick.pushtags[wSlam.?,wMain]
        perform eachpick.pushtags[nSlam.?,Value]
      Endif
      If (eachpick.tagis[thingid.wTailSlap] + tagcount[wTailSlap.?] = 2) Then
        perform eachpick.pushtags[wTailSlap.?,wMain]
        perform eachpick.pushtags[nTailSlap.?,Value]
      Endif
      If (eachpick.tagis[thingid.wTalon] + tagcount[wTalon.?] = 2) Then
        perform eachpick.pushtags[wTalon.?,wMain]
        perform eachpick.pushtags[nTalon.?,Value]
      Endif
      If (eachpick.tagis[thingid.wTentacle] + tagcount[wTentacle.?] = 2) Then
        perform eachpick.pushtags[wTentacle.?,wMain]
        perform eachpick.pushtags[nTentacle.?,Value]
      Endif
      If (eachpick.tagis[thingid.wTrample] + tagcount[wTrample.?] = 2) Then
        perform eachpick.pushtags[wTrample.?,wMain]
        perform eachpick.pushtags[nTrample.?,Value]
      Endif
      If (eachpick.tagis[thingid.wWing] + tagcount[wWing.?] = 2) Then
        perform eachpick.pushtags[wWing.?,wMain]
        perform eachpick.pushtags[nWing.?,Value]
      Endif
    nexteach

    ~ Fine
    If (tagis[RaceSize.Fine14] <> 0) Then
      sizetarget = -4
    ~ Diminutive
    ElseIf (tagis[RaceSize.Dimin13] <> 0) Then
      sizetarget = -3
    ~ Tiny
    ElseIf (tagis[RaceSize.Tiny12] <> 0) Then
      sizetarget = -2
    ~ Small
    ElseIf (tagis[RaceSize.Small11] <> 0) Then
      sizetarget = -1
    ~ Medium
    ElseIf (tagis[RaceSize.Medium0] <> 0) Then
      sizetarget = 0
    ~ Large
    ElseIf (tagis[RaceSize.Large1] <> 0) Then
      sizetarget = 1
    ~ Huge
    ElseIf (tagis[RaceSize.Huge2] <> 0) Then
      sizetarget = 2
    ~ Gargantuan
    ElseIf (tagis[RaceSize.Gargant3] <> 0) Then
      sizetarget = 3
    ~ Colossal
    ElseIf (tagis[RaceSize.Colossal4] <> 0) Then
      sizetarget = 4
    Endif

    ~Loop through each armor on the character and assign Meld into Form Tag
    foreach pick in hero from BaseArmor where "!thingid.mNatural & (EquipType.Armor|EquipType.Shield)"
        perform eachpick.assign[WildShape.MeldGear]
    nexteach

    ~make sure the user didn't enter a size greater than colossal (+4), or
    ~smaller than fine (-4)
    sizetarget = maximum(sizetarget, -4)
    sizetarget = minimum(sizetarget, 4)
   
    ~calculate the modifier we need
    sizemod = sizetarget - herofield[tSize].value 

    ~if, at this point, sizemod = 0, then there's no change to apply, and we'll
    ~just get out now
    if (sizemod <> 0) then

      ~ Add to size - must come after race and template size set
      herofield[tSize].value += sizemod

      ~ Change the size of all our equipment (apart from unarmed
      ~ strike, which changes automatically)
      foreach pick in hero from MyGear where "!wCategory.Unarmed & !Helper.GearNoSize"
        eachpick.field[gSizeMod].value += sizemod
      nexteach
     
      var i as number

      ~ change the size of our natural weapons
      foreach pick in hero from BaseNatWep where "!Helper.NatSizeDmg & !PolyAdjust.Weapon"
        i = 0
        ~ Bigger then up damage
        if (sizemod > 0) then
          for i = 1 to sizemod
            perform eachpick.assign[Helper.DamageUp]
          next
        ~ Smaller then down the damage
        elseif (sizemod < 0) then
          for i = sizemod to -1
            perform eachpick.assign[Helper.DamageDown]
          next
        endif
      nexteach
    endif

    ~ Setup any poison affects
    Call SCPolyPois
    ~ Setup any web affects
    Call SCPolyWeb
    ~ Setup any jet affects
    Call SCPolyJet
    ]]>
  </procedure>

<!-- =================================================================== -->
<!-- 
     This procedure calculates the correct cost and pages of a spellbook
     based on CORE book rules.
-->
<!-- =================================================================== -->
  <procedure id="CalcSpBook" context="pick"><![CDATA[
    ~ This procedure calculates the cost, weight, and number of spellbooks needed for a selected class
    ~ The Value.? tag on the Thing stores the number of pages the spellbook can hold.
    ~ The weight is set once to figure out what the base weight of the spellbook is.

    ~ Parms in and out of the procedure
    var Cost   as number
    var Pages  as number
    var Weight as number
    var Books  as number

    ~ Work fields
    var S2Weight as number
    var S2Class as string

    ~ Get the Spellbook Class ID
    S2Class = field[usrChosen1].chosen.tagids[Spellbook.?,"|"]

    ~ Read through all the spells on the selected class
    foreach pick in hero from BaseSpell where S2Class
       ~ Total up the Cost and number of pages used at each spell level
       If (eachpick.tagis[sLevel.0] <> 0) Then
          Cost += 5
          Pages += 1
       elseIf (eachpick.tagis[sLevel.1] <> 0) Then
          Cost += 10
          Pages += 1
       elseIf (eachpick.tagis[sLevel.2] <> 0) Then
          Cost += 40
          Pages += 2
       elseIf (eachpick.tagis[sLevel.3] <> 0) Then
          Cost += 90
          Pages += 3
       elseIf (eachpick.tagis[sLevel.4] <> 0) Then
          Cost += 160
          Pages += 4
       elseIf (eachpick.tagis[sLevel.5] <> 0) Then
          Cost += 250
          Pages += 5
       elseIf (eachpick.tagis[sLevel.6] <> 0) Then
          Cost += 360
          Pages += 6
       elseIf (eachpick.tagis[sLevel.7] <> 0) Then
          Cost += 490
          Pages += 7
       elseIf (eachpick.tagis[sLevel.8] <> 0) Then
          Cost += 640
          Pages += 8
       elseIf (eachpick.tagis[sLevel.9] <> 0) Then
          Cost += 810
          Pages += 9
       Endif
    nexteach
    ~ Calc the number of books
    Books = round(maximum(Pages/tagvalue[Value.?],1),0,1)
    ~ Calc books total weight based on weight of a single book
    Weight = Books * field[gWeight].value
    ~ Calc how much weight to add to the hero subtracting out the current weight of one book
    S2Weight = Weight - field[gWeight].value
    ~ Set the item weight
    field[gWeight].value += S2Weight
    ~ Set the item weight
    field[gearWeight].value += S2Weight
    
    ~ Set the desc with info
    field[DescAppend].text = "{B}Cost:{/B} " & digitgroup(Cost) & "gp" & "{br}" & "{B}Pages:{/B} " & Pages
    ]]>
    </procedure>


</document>